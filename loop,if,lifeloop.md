# 条件分支，循环，生命周期



> 这节简单，建议姿势：躺着

## 条件分支

条件分支，最简单的实现就是if-else结构。

C：

````c
if(条件1){
    语句;
}else if(条件2){
    语句;
}else{
    语句;
}
````

Python：

````python
if 条件1:
    语句
elif 条件2:
    语句
else:
    语句
````

需要注意的是，这里的`else if`结构和`elif`结构是可以有多个的，但是`else`结构在一个`if`下只能有一个。

这里的”条件“，应当时是一个能判断真假的式子，我们称这种表达式为**布尔表达式（Boolean expression）**（取名布尔是为了纪念数学家乔治·布尔，二元逻辑和计算机的先驱），这种表达式结果应当只有两个值，真，假，也就是`true`和`false`，是不是很像数学中的命题？（笑）

但是啊，C里面可没有什么表示真假的变量类型，那怎么办？于是规定了，在C语言中，能判断则判断，如果你在括号里填入了一个值，为零则为假，其他的不为零的结果都为真。这是特性之一。

欸？那我写  **if-else if**  结构和我写 **多个 if** 结构有什么区别呢？

对于同一个值来说，进入  **if-else if**  结构后，只会进入一个分支，也就是说如果有一个条件符合了，那么下面的就不看了。而对于 **多个 if** 的结构，一定会把这几个条件都判断一遍。在实际应用中，要注意区分两种结构，使用的时候根据需要选择。

Python的条件分支只有这一种结构，而C中还有另外一种结构：switch-case结构。我们先看看长什么样：

````C
switch(一个常量){
    case 一个可能的值:
        语句
    case 另一个可能的值:
        语句
    default:
        语句
}
````

这种结构的规则是，用括号中的常量从上往下依次和case后面的值进行比对，如果有符合的，则**向下执行完所有的代码**，如果没有复合的，那就执行`default`。什么反人类设计。不过还好，我们有一个语句可以强制跳出switch。`break`语句可以让我们跳出switch-case这个大括号外，因此一般使用这种结构的时候，会写成：

````C
switch(一个常量){
    case 一个可能的值:
        语句
        break;
    case 另一个可能的值:
        语句
        break;
    default:
        语句
}
````

我也见过直接用的例子，这个switch-case结构就像一个漏斗一样，可以做到一个分类的作用，例如：

````C
switch(fruit){
    case apple:
    case strawberry:
    case peach:
        printf("红色的水果");
        break;
    case banana:
    case mango:
        printf("黄色的水果");
        break;
    default:
        printf("没见过的水果");
}
````

------

## 循环结构

这里，C和python要分开讲，两者差距有亿点大。

**先说C。**

C中有三种循环结构，for，while，do-while。

**for循环**结构是这样的：

````c
for(初始化语句;循环条件;更新语句){
    语句（我们在这里称之为循环体）
}
````

**初始化语句**是在进入for循环中时首先执行的代码，一般我们在这里定义一个循环变量。

**循环条件**，当执行条件为真时，执行循环体。

**更新语句**，在执行完循环体之后会先执行这个，再判断循环条件的真假。

当然，你要是愿意，这三个位置你都是可以空着的（但是分号不能省）。循环条件为空时，默认为真，也就是进入死循环。

没看懂？看看这个程序框图（这里的表达式3就是我们说的更新语句。）：

![img](https://c.biancheng.net/uploads/allimg/181228/13401Q911-0.jpg)



看个例子，我们要按顺序输出1-100 ：

````c
#include <stdio.h>
int main()
{
   for(int i=1; i<=100; i=i+1){
       printf("%d ",i);
	}
   return 0;
}
````

感觉`i=i+1`还是太麻烦了，C提供了一种**自增**的运算符，有+=，-=，++，--，这里先简单说几种用法，左边是这种符号的用法，右边是等效写法：

````c
a++   ==>  a+=1  ==>  a=a+1
a--   ==>  a-=1  ==>  a=a-1
a+=2  ==>  a=a+2
a-=2  ==>  a=a-2
````

所以for那一行也可以写成：

````c
for(int i=1; i<=100; i++)
````

反正我一般都喜欢这么写。

**while结构**：

这个简单，结构如下：

````c
while(循环条件){
    循环体
}
````

进入后先判断条件是否符合，然后执行。给个例子，同样是按顺序输出1-100 ：

````c
#include <stdio.h>
int main()
{
    int i = 1;
    while(i<=100){
       printf("%d ",i);
        i++;
	}
   return 0;
}
````

能看出来吗，这里我们就需要把原来写在for的括号里的东西分散的写在各个地方，for的好处之一就是你可以把这些东西写在一个地方。

**do-while结构**：

结构如下：

````c
do{
    循环体
}while(条件)
````

和上面是不是很相似？那有什么区别呢？从结构上看，while结构把判断条件放在了前面，而do-while把判断条件放在了后面。因此这两个的本质区别就是，一个是在**执行循环体之前**判断条件是否成立，一个时在**执行循环体之后**进行判断。这就引出了一个需要注意的点：如果使用do-while结构，那么无论循环条件成立与否，**循环体一定会执行至少一次**，再去判断条件是否符合。

C的循环到此。

-----

**对于Python**，有for循环和while循环，先说for循环：

与其说是for循环，倒不如说叫做for遍历，结构如下：

````python
for 变量名 in 可迭代对象:
    循环体
````

先说后面的**可迭代对象**，你先理解成类似列表的东西，总之就是必须是一组东西，无论是数组，字典，元组，甚至是字符串，都不是一个数据，它是一组数据打一个包，我就统称为列表。

for结构的目的就是遍历列表中的每一个对象，因此我们在循环体中肯定是要用到的。这里的**变量名**就是声明了一个变量，用来指代列表中的**每一个**对象。

那如果我就是想循环9次，难道我要直接敲出一个[1,2,3,4,5,6,7,8,9]来作为遍历的列表吗？那我要是想循环100次呢？python提供了`range()`函数可以生成这种数字列表，用法如下：

````py
range(左界,右界)
range(左界,右界,步长=1)
````

例如：

````py
range(0,4)  ==>  [0,1,2,3]
range(5,11,2)  ==>  [5,7,9]
range(9,4)  ==>  []
range(9,4,-1)  ==>  [9,8,7,6,5]
range(7,-4,-3)   ==>  [7,4,1,-2]
````

逐行解释：

1.基础用法，注意，range()的左右界遵循**包左不包右**的原则，就像这个例子一样，包含0，但是不包含4。

2.加入步长这个参数，就可以实现跳着取数，默认步长是1。

3.如果想获得一个倒着的数列，直接这么写是不行的，因为默认步长是1，正着向前迈步怎么会得到倒退的数列呢？

4.应该这么写，将步长设置为倒着的就可以啦！（神金）

5.当然，倒着的数列也支持跨步。

让我们把range()函数和for语句结合在一起：输出1-100的例子：

````python
for i in range(1,101):
    print(i)
````

